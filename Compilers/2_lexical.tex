% !TEX root = main.tex

\section{词法分析}
分离词法分析和语法分析可以简化这两个任务，同时提升编译器的性能与兼容性。

\subsection{基本定义}
\begin{definition}
令牌(token)是一个\underline{令牌名字}与\underline{可选属性值}构成的对；模式(pattern)描述了每个词素(lexeme)要遵循什么规则；而词素（最小意义单位）则是源程序中一连串满足模式的字母，作为令牌的实例化。
\end{definition}
\begin{example}
考虑C语句\\
 \qquad\qquad\verb'printf("Total = %d\n", score);'\\
其中\verb'printf'和\verb'score'是匹配(match)上令牌\textbf{id}模式的词素，而\verb'"Total = %d\n"'是匹配上字面值\textbf{literal}的词素。
\end{example}
简单来讲，令牌是一个更大的概念，是同类词素的集合。
比如一个令牌\textbf{comparison}的样例词素可以有\texttt{<=}和\texttt{!=}。

\begin{definition}[字母表与语言]
字母表(alphabet)$\Sigma$是有限符号(symbol)的集合，如ASCII就是一个字母表。
字符串(string)$s$是从字母表中抽取的有限符号的序列，$|s|$为字符串长度，$\epsilon$为空串。
语言(language)是字符串的可数集合。
\end{definition}
\begin{example}
字母表$\Sigma=\{0,1\}$，则$\{001,1001\}$和$\{\}$都是定义在$\Sigma$上的语言。
\end{example}

\begin{definition}[字符串术语]
前缀(prefix)和后缀(suffix)都可以包括$\epsilon$。
字串(substring)可通过删除任意前缀和任意后缀（包括\textbf{零个}）获得。
真(proper)字串则不包含$\epsilon$。
子序列(subsequence)是删除\textbf{零个}或多个\textbf{不一定连续}的字母得到的字符串。
\end{definition}

语言是一种集合，故集合运算也适用于语言。
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}\hline
并集(union) & $L\cup M$\\\hline
连接(concatenation)/交集 & $LM$\\\hline
柯林闭包(Kleene closure) & $L^*=\cup_{i=0}^\infty L^i$\\\hline
正闭包(positive) & $L^+=\cup_{i=1}^\infty L^i$\\\hline
\end{tabular}
\end{table}

\subsection{正则表达式}
\begin{definition}[正则表达式(regular expression, regex)]
正则表达式$r$定义了语言$L(r)$，以递归形式定义：
\begin{enumerate}
	\item 奠基：
	\begin{itemize}
		\item $\epsilon$是正则表达式，即$L(\epsilon)=\{\epsilon\}$
		\item $a\in\Sigma$是正则表达式，即$L(\va)=\{a\}$（这里用斜体代表符号，粗体代表符号对应的正则表达式）
	\end{itemize}
	\item 推论(induction)：若$r$和$s$都是正则表达式给出了语言$L(r)$和$L(s)$，则
	\begin{itemize}
		\item $(r)|(s)$是正则表达式，表示$L(r)\cup L(s)$
		\item $(r)(s)$是正则表达式，表示$L(r)L(s)$
		\item $(r)^*$是正则表达式，表示$(L(r))^*$
		\item $(r)$是正则表达式，表示$L(r)$
	\end{itemize}
\end{enumerate}
正则表达式表示的语言叫做正规集。
\end{definition}

有以下运算规定：
\begin{itemize}
	\item 一元运算符${}^*$有最高优先级，左结合
	\item 连接优先级次之，左结合
	\item $|$优先级\textbf{最低}，左结合
\end{itemize}

\begin{definition}[正则定义]
$d_i\to r_i$，其中$d_i$都是名字，且各不相同。
每个$r_i$是$\Sigma\cup\{d_1,\ldots,d_{i-1}\}$中符号上的正则表达式。
\end{definition}
\begin{example}
比如C语言的标识符可记为
\[\begin{aligned}
letter\_ &\to A|B|\cdots|Z|a|b|\cdots|z|\_\\
digit &\to 0|1|\cdots|9\\
id &\to letter\_(letter\_|digit)^*
\end{aligned}\]
\end{example}

正则表达式的拓展\footnote{更多可参见\href{https://regex101.com/}{Regex101}}：
\begin{itemize}
	\item $r^+$代表一个或多个
	\item $r?$代表零或一个
	\item $[a-z]$字母类
\end{itemize}

\subsection{有限自动机}
\subsubsection{确定性/非确定性有限自动机}
确定有限自动机(DFA)不可对$\epsilon$进行移动，而且对于每一状态$s$，输入符号$a$，只有唯一一条出边标记为$a$；而非确定性有限自动机(NFA)可能有多种转换路径。
有限状态集$S$，状态$s_0\in S$为初始状态(start/initial)，$F\subset S$为终止状态(accepting/final)。
\begin{example}
识别语言$L((a|b)^*abb)$，下面为一个NFA
\begin{center}
% http://madebyevan.com/fsm/
% \begin{tikzpicture}[scale=0.2]
% \tikzstyle{every node}+=[inner sep=0pt]
% \draw [black] (22.6,-23.6) circle (3);
% \draw (22.6,-23.6) node {$0$};
% \draw [black] (34.6,-23.6) circle (3);
% \draw (34.6,-23.6) node {$1$};
% \draw [black] (47.3,-23.6) circle (3);
% \draw (47.3,-23.6) node {$2$};
% \draw [black] (59.5,-23.6) circle (3);
% \draw (59.5,-23.6) node {$3$};
% \draw [black] (59.5,-23.6) circle (2.4);
% \draw [black] (21.277,-20.92) arc (234:-54:2.25);
% \draw (22.6,-16.35) node [above] {$a$};
% \fill [black] (23.92,-20.92) -- (24.8,-20.57) -- (23.99,-19.98);
% \draw [black] (23.923,-26.28) arc (54:-234:2.25);
% \draw (22.6,-30.85) node [below] {$b$};
% \fill [black] (21.28,-26.28) -- (20.4,-26.63) -- (21.21,-27.22);
% \draw [black] (25.6,-23.6) -- (31.6,-23.6);
% \fill [black] (31.6,-23.6) -- (30.8,-23.1) -- (30.8,-24.1);
% \draw (28.6,-24.1) node [below] {$a$};
% \draw [black] (37.6,-23.6) -- (44.3,-23.6);
% \fill [black] (44.3,-23.6) -- (43.5,-23.1) -- (43.5,-24.1);
% \draw (40.95,-24.1) node [below] {$b$};
% \draw [black] (50.3,-23.6) -- (56.5,-23.6);
% \fill [black] (56.5,-23.6) -- (55.7,-23.1) -- (55.7,-24.1);
% \draw (53.4,-24.1) node [below] {$b$};
% \draw [black] (15.4,-23.6) -- (19.6,-23.6);
% \draw (14.9,-23.6) node [left] {$start$};
% \fill [black] (19.6,-23.6) -- (18.8,-23.1) -- (18.8,-24.1);
% \end{tikzpicture}
\begin{tikzpicture}
\node[state, initial] (0) {$0$};
\node[state, right of=0] (1) {$1$};
\node[state, right of=1] (2) {$2$};
\node[state, accepting, right of=2] (3) {$3$};
\draw (0) edge[loop above] node{$a$} (0)
(0) edge[loop below] node{$b$} (0)
(0) edge[above] node{$a$} (1)
(1) edge[above] node{$b$} (2)
(2) edge[above] node{$c$} (3);
\end{tikzpicture}
\end{center}
\end{example}

判别字符串能否被DFA识别很简单，只需要读入字符按照状态转移表跳转，判断末态是不是终态即可。
\begin{algorithm}[H]
\centering
\caption{基于DFA的识别算法}
\begin{algorithmic}[1]
\State $s=s_0$
\State $c=nextChar()$
\While{($c$!=\textbf{eof})}
\State $s=move(s,c)$
\State $c=nextChar()$
\EndWhile
\If{$s\in F$}
\State
\Return ``yes''
\Else
\Return ``no''
\EndIf
\end{algorithmic}
\end{algorithm}
时间复杂度为$O(|str|)$。

\subsubsection{正则表达式转NFA}
% https://www3.nd.edu/~kogge/courses/cse30151-fa17/Public/other/tikz_tutorial.pdf

\begin{enumerate}
	\item 奠基
\begin{itemize}
\item 对于表达式$\epsilon$，构建NFA
\begin{center}
\begin{tikzpicture}
\node[state, initial] (1) {$i$};
\node[state, accepting, right of=1] (2) {$f$};
\draw (1) edge[above] node{$\epsilon$} (2);
\end{tikzpicture}
\end{center}

\item 对于任意子表达式$a\in\Sigma$，构建NFA
\begin{center}
\begin{tikzpicture}
\node[state, initial] (1) {$i$};
\node[state, accepting, right of=1] (2) {$f$};
\draw (1) edge[above] node{$a$} (2);
\end{tikzpicture}
\end{center}
\end{itemize}
	\item 推论
\begin{itemize}
\item $r=s|t$，取并集
\begin{center}
\begin{tikzpicture}
\node[state, initial] (1) {$i$};
\node[state, above right of=1] (2) {};
\node[state, below right of=1] (3) {};
\node[state, right of=2] (4) {};
\node[state, right of=3] (5) {};
\node[state, accepting, below right of=4] (6) {$f$};
\draw (1) edge[above] node{$\epsilon$} (2)
(1) edge[below] node{$\epsilon$} (3)
(4) edge[above] node{$\epsilon$} (6)
(5) edge[below] node{$\epsilon$} (6);
\begin{pgfonlayer}{background}
\node[fit=(2)(4), fill=gray!30, ellipse] {$N(s)$};
\node[fit=(3)(5), fill=gray!30, ellipse] {$N(t)$};
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

\item $r=st$，取连接
\begin{center}
\begin{tikzpicture}[node distance=3cm,
	FIT/.style args = {#1/#2/#3}{ellipse, fill=#1, inner xsep=#2, fit=#3}]
\node[state, initial] (1) {$i$};
\node[state, right of=1] (2) {};
\node[state, accepting, right of=2] (3) {$f$};
\node[right=0.41cm of 1] {$N(s)$};
\node[right=0.41cm of 2] {$N(t)$};
% \draw[draw=gray!30,arrows={->[gray!30]}] (1) edge[above] node{$N(s)$} (2);
% \draw[draw=gray!30,arrows={->[gray!30]}] (2) edge[above] node{$N(t)$} (3);
\begin{pgfonlayer}{background}
\node[FIT=gray!30/-5mm/(1)(2), draw=black, opacity=0.6] {};
\node[FIT=gray!30/-5mm/(2)(3), draw=black, opacity=0.6] {};
\end{pgfonlayer}
\end{tikzpicture}
\end{center}

\item $r=s^*$，Kleene闭包
\begin{center}
\begin{tikzpicture}[node distance=3.2cm,
	FIT/.style args = {#1/#2/#3}{ellipse, fill=#1, inner xsep=#2, fit=#3}]
\node[state, initial] (1) {$i$};
\node[state, right of=1] (2) {};
\node[state, right of=2] (3) {};
\node[state, accepting, right of=3] (4) {$f$};
\draw (1) edge[above] node{$\epsilon$} (2)
(1) edge[bend right, below] node{$\epsilon$} (4)
(3) edge[above, bend right] node(e){$\epsilon$} (2)
(3) edge[below] node{$\epsilon$} (4);
\begin{pgfonlayer}{background}
\node[FIT=gray!30/-5mm/(2)(3)] {$N(s)$};
\end{pgfonlayer}
\end{tikzpicture}
\end{center}
\end{itemize}
\end{enumerate}

\subsubsection{NFA转DFA}
\begin{definition}[$\epsilon$闭包及$move$]
$\epsilon$闭包是可通过NFA的$\epsilon$边转换的状态。
$move(T,a)$为状态$s\in T$通过输入符号$a$可到达的新的状态。
\end{definition}
\begin{algorithm}[H]
\centering
\caption{子集构造（NFA转DFA）}
\begin{algorithmic}[1]
\Require NFA $N$
\Ensure DFA $D$（与$N$接受相同的语言）
\State $\epsilon$-$closure(s_0)$是$Dstates$的唯一状态，且未被标记(unmarked)
\While{在$Dstates$中还有未被标记的状态$T$}
\State 标记$T$
\For{每一个输入符号$a$}
\State $U=\epsilon$-$closure(move(T,a))$
\If{$U\notin Dstates$}
\State 将$U$作为未标记的状态加入$Dstates$
\EndIf
\State $Dtran[T,a]=U$
\EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{example}
考虑以下NFA：
\begin{center}
\begin{tikzpicture}[scale=0.6]
\node[state, initial] (0) {0};
\node[state, accepting, above right of=0] (1) {1};
\node[state, right of=1] (3) {3};
\node[state, accepting, below right of=0] (2) {2};
\node[state, right of=2] (4) {4};
\draw (0) edge[bend left, above] node{$\epsilon$} (1)
(0) edge[bend right, below] node{$\epsilon$} (2)
(1) edge[loop above] node{$a$} (1)
(2) edge[loop below] node{$b$} (2)
(1) edge[bend left, above] node{$b$} (3)
(3) edge[below] node{$b$} (1)
(3) edge[loop above] node{$a$} (3)
(2) edge[bend left, above] node{$a$} (4)
(4) edge[below] node{$a$} (2)
(4) edge[loop below] node{$b$} (4);
\end{tikzpicture}
\end{center}
\begin{enumerate}
	\item 这一NFA接受什么语言（用自然语言描述）？
	\item 构造接受同一语言的DFA.
\end{enumerate}
\end{example}
\begin{analysis}
\begin{enumerate}
	\item 含有偶数个$a$或偶数个$b$的由$a$、$b$构成的字符串，或者全是$a$或全是$b$
	\item 由subset construction算法构造如下
\begin{center}
\begin{tabular}{|l|l|l|l|}\hline
NFA & DFA & $a$ & $b$\\\hline
$\{0,\underline{1,2}\}$ & $A$ & $\{1,4\}$ & $\{2,3\}$\\\hline
$\{\underline{1},4\}$ & $B$ & $\{1,2\}$ & $\{3,4\}$\\\hline
$\{\underline{2},3\}$ & $C$ & $\{3,4\}$ & $\{1,2\}$\\\hline
$\{\underline{1,2}\}$ & $D$ & $\{1,4\}$ & $\{2,3\}$\\\hline
$\{3,4\}$ & $E$ & $\{2,3\}$ & $\{1,4\}$\\\hline
\end{tabular}
\end{center}
\begin{center}
\begin{tikzpicture}
\node[state] (4) {$E$};
\node[state, accepting, initial, left of=4] (0) {$A$};
\node[state, accepting, above of=4] (1) {$B$};
\node[state, accepting, below of=4] (2) {$C$};
\node[state, accepting, right of=4] (3) {$D$};
\draw (0) edge[bend left, above] node{$a$} (1)
(0) edge[bend right, below] node{$b$} (2)
(1) edge[bend left, above] node{$a$} (3)
(1) edge[bend left, above] node{$b$} (4)
(2) edge[bend right, below] node{$a$} (4)
(2) edge[bend right, below] node{$b$} (3)
(3) edge[above] node{$a$} (1)
(3) edge[below] node{$b$} (2)
(4) edge[above] node{$a$} (2)
(4) edge[below] node{$b$} (1);
\end{tikzpicture}
\end{center}
\end{enumerate}
\end{analysis}

直接用NFA识别语言算法如下，需要每次算所有当前\textbf{可能状态}执行动作$c$后的$\epsilon$闭包。
\begin{algorithm}[H]
\centering
\caption{子集构造（NFA转DFA）}
\begin{algorithmic}[1]
\State $S=\epsilon$-$closure(s_0)$
\State $c=nextChar()$
\While{$c$!=\textbf{eof}}
\State $S=\epsilon$-$closure(move(S,c))$
\State $c=nextChar()$
\EndWhile
\If {$S\cap F$!=$\varnothing$}
\State\Return ``yes''
\Else
\State\Return ``no''
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{theorem}
DFA，NFA和正则表达式三者的描述能力是一样的。
\end{theorem}